#!/usr/bin/python3

'''
Run command on multiple hosts.

Usage:
  run_all [-t <tag>] [--user=<user>] [--pass=<pass>] <command>
  run_all [-t <tag>] [--user=<user>] [--pass=<pass>] --script <script>
  run_all [-t <tag>] [--user=<user>] [--pass=<pass>] --copy-keys

Options:
  -t <tag>       Only consider hosts with <tag>.
  --user=<user>  Username to use for the remote host.
  --pass=<pass>  Password to use for sshpass.
  --copy-keys    Copy local ssh keys to remote servers.

Arguments:
  <command>  Command to run.
'''

__version__ = '0.1'

import sys
import docopt
import os
import pwd
import socket
import time
import pty
import signal
import select
import shlex
import struct
import termios
import fcntl


HOSTS = [
	'admiral.podgorny.cz arch linux podgorny',
	'berta.podgorny.cz arch arm linux podgorny',
	'chuck.podgorny.cz arch linux podgorny',
	'europa.podgorny.cz arch arm linux podgorny router',
	'hubert.asterix.cz arch asterix linux',
	'kulicka.podgorny.cz arch arm linux podgorny',
	'milan.podgorny.cz arch arm linux podgorny',
	'milhouse.podgorny.cz arch linux podgorny sureboot',
	'mrtvola.asterix.cz arch asterix linux',
	'orion.asterix.cz arch asterix linux sureboot',
	'pimiento.podgorny.cz arch linux podgorny',
	'kapitan.podgorny.cz gentoo linux podgorny',
	'pokuston.podgorny.cz arch arm linux podgorny',
	'rpodgorny.podgorny.cz arch linux podgorny',
	'simir.podgorny.cz arch linux podgorny',
	'taurus.asterix.cz arch asterix linux router',
	'ucho.podgorny.cz arch arm linux podgorny',
]

#for i in range(1, 13):
#	HOSTS.append('miner%d.asterix.cz arch asterix linux miner' % i)
#endfor

for i in range(1, 200):
	HOSTS.append('mj%d.asterix.cz asterix atx300 windows' % i)
#endfor

for i in range(1, 2000):
	HOSTS.append('mj%dd.asterix.cz asterix windows' % i)
#endfor


PUB_KEY_FN = os.path.expanduser('~/.ssh/id_ecdsa.pub')


class color:
	PURPLE = '\033[95m'
	CYAN = '\033[96m'
	DARKCYAN = '\033[36m'
	BLUE = '\033[94m'
	GREEN = '\033[92m'
	YELLOW = '\033[93m'
	RED = '\033[91m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'
	END = '\033[0m'
#endclass


def check_pub_key(fn):
	with open(fn, 'r') as f:
		line = f.readline()
	#endwith

	user_and_host = line.split()[-1]
	user, host = user_and_host.split('@')

	if user != pwd.getpwuid(os.getuid())[0]: return False
	if host != socket.gethostname(): return False

	return True
#enddef


def fork_it(cmd):
	pid, f = pty.fork()
	if pid == 0:
		argv = shlex.split(cmd)
		os.execlp(argv[0], *argv)
	else:
		return pid, f
	#endif
#enddef


def check_pid(pid):
	try:
		os.kill(pid, 0)
	except OSError:
		return False
	#endtry

	return True
#enddef


def main():
	args = docopt.docopt(__doc__, version=__version__)

	tag = args['-t']

	hosts = set()
	for i in HOSTS:
		host, *tags = i.split()
		if not tag or tag in tags:
			hosts.add(host)
		#endif
	#endfor

	hosts_to_go = hosts
	hosts = set()

	forks = []
	rets = {}

	cols, rows = os.get_terminal_size()

	total = len(hosts_to_go)
	i = 0
	while forks or hosts_to_go:
		while len(forks) < 10 and hosts_to_go:
			host = sorted(list(hosts_to_go))[0]
			hosts_to_go.remove(host)

			if args['--user']:
				host_full = '%s@%s' % (args['--user'], host)
			else:
				host_full = host
			#endif

			if args['--copy-keys']:
				if not check_pub_key(PUB_KEY_FN):
					raise Exception('i don\'t like the public key')
				#endif

				cmd = 'ssh-copy-id -i %s %s' % (PUB_KEY_FN, host_full)
			elif args['<script>']:
				cmd = 'ssh -o ConnectTimeout=2 %s "a=`mktemp`; cat >\$a; chmod a+x \$a; \$a; rm \$a" <%s' % (host_full, args['<script>'])
			elif args['<command>']:
				# the -t seems to be breaking logins to windows machines
				#cmd = 'ssh -o ConnectTimeout=2 -t %s "%s"' % (host_full, args['<command>'])

				cmd = 'ssh -o ConnectTimeout=2 -t %s "%s"' % (host_full, args['<command>'])
			#endif

			if args['--pass']:
				if not os.path.isfile('/usr/bin/sshpass'):
					raise Exception('/usr/bin/sshpass does not exist')
				#endif

				cmd = '/usr/bin/sshpass -p%s %s' % (args['--pass'], cmd)
			#endif

			pid, f = fork_it(cmd)
			fcntl.ioctl(f, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))
			forks.append((cmd, pid, f))
		#endwhile

		if not forks:
			time.sleep(0.1)
			continue
		#endif

		# pick the first one
		#cmd, pid, f = forks[0]

		# pick the dead one (with fallback to last one if everyone is alive)
		for cmd, pid, f in forks:
			if not check_pid(pid): break
		#endfor

		forks.remove((cmd, pid, f))

		i += 1

		print('%s(%d/%d) %s%s%s' % (color.YELLOW, i, total, color.BOLD, cmd, color.END))

		out = bytes()
		while 1:
			if out:
				w = [f]
			else:
				w = []

			# TODO: this is probably useless - it mostly fails in time.sleep() below
			try:
				r, w, x = select.select([f, sys.stdin], w, [], 0)
			except KeyboardInterrupt:
				out += b'\x03'
			#endtry

			if f in r:
				try:
					xxx = os.read(f, 10000).decode()
				except:
					break
				sys.stdout.write(xxx)
				sys.stdout.flush()
			#endif

			if f in w:
				os.write(f, out)
				out = bytes()
			#endif

			if sys.stdin in r:
				#print('ha')
				inp = sys.stdin.readline().encode()
				#print('inp: %s' % inp)
				if not inp:
					out += b'\x04'
				else:
					out += inp
				#endif
			#endif

			if sys.stdin in x:
				print('XXX')
			#endif

			try:
				time.sleep(0.01)
			except KeyboardInterrupt:
				out += b'\x03'
			#endtry
		#endwhile

		os.close(f)
		_, ret = os.waitpid(pid, 0)

		if not ret in rets:
			rets[ret] = set()
		#endif

		rets[ret].add(host)
	#endwhile

	ss = []
	for ret in sorted(rets.keys()):
		if ret == 0:
			s = color.GREEN
		else:
			s = color.RED
		#endif

		s += '%s: %d' % (ret, len(rets[ret]))
		ss.append(s)
	#endfor

	print('%srets: %s%s' % (color.YELLOW, ', '.join(ss), color.END))
#enddef


if __name__ == '__main__':
	main()
#enddef
