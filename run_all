#!/usr/bin/python3

'''
Run command on multiple hosts.

Usage:
  run_all [-t <tag>] [--user=<user>] [--pass=<pass>] <command>
  run_all [-t <tag>] [--user=<user>] [--pass=<pass>] [--sudo] --script <script>
  run_all [-t <tag>] [--user=<user>] [--pass=<pass>] --copy-keys

Options:
  -t <tag>       Only consider hosts with <tag>.
  --user=<user>  Username to use for the remote host.
  --pass=<pass>  Password to use for sshpass.
  --sudo         Use sudo on remote system.
  --copy-keys    Copy local ssh keys to remote servers.

Arguments:
  <command>  Command to run.
'''

__version__ = '0.1'

import sys
import docopt
import os
import pwd
import socket
import time
import pty
import signal
import select
import shlex
import struct
import termios
import fcntl


HOSTS = [
	'admiral.podgorny.cz arch linux podgorny',
	'berta.podgorny.cz arch arm linux podgorny',
	'chuck.podgorny.cz arch linux podgorny',
	'europa.podgorny.cz arch arm linux podgorny router',
	'hubert.asterix.cz arch asterix linux',
	'kulicka.podgorny.cz arch arm linux podgorny',
	'milan.podgorny.cz arch arm linux podgorny',
	'milhouse.podgorny.cz arch linux podgorny sureboot',
	'mrtvola.asterix.cz arch asterix linux',
	'orion.asterix.cz arch asterix linux sureboot',
	'pimiento.podgorny.cz arch linux podgorny',
	'kapitan.podgorny.cz gentoo linux podgorny',
	'pokuston.podgorny.cz arch arm linux podgorny',
	'rpodgorny.podgorny.cz arch linux podgorny',
	'simir.podgorny.cz arch linux podgorny',
	'taurus.asterix.cz arch asterix linux router',
	'ucho.podgorny.cz arch arm linux podgorny',
]

#for i in range(1, 13):
#	HOSTS.append('miner%d.asterix.cz arch asterix linux miner' % i)
#endfor

for i in range(1, 200):
	HOSTS.append('mj%d.asterix.cz asterix atx300 windows' % i)
#endfor

for i in range(1, 2000):
	HOSTS.append('mj%dd.asterix.cz asterix windows' % i)
#endfor


PUB_KEY_FN = os.path.expanduser('~/.ssh/id_ecdsa.pub')
MAX_FORKS = 10
DEBUG = 0


class color:
	PURPLE = '\033[95m'
	CYAN = '\033[96m'
	DARKCYAN = '\033[36m'
	BLUE = '\033[94m'
	GREEN = '\033[92m'
	YELLOW = '\033[93m'
	RED = '\033[91m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'
	END = '\033[0m'
#endclass


def check_pub_key(fn):
	with open(fn, 'r') as f:
		line = f.readline()
	#endwith

	user_and_host = line.split()[-1]
	user, host = user_and_host.split('@')

	if user != pwd.getpwuid(os.getuid())[0]: return False
	if host != socket.gethostname(): return False

	return True
#enddef


def fork_it(cmd):
	pid, f = pty.fork()
	if pid == 0:
		argv = shlex.split(cmd)
		os.execlp(argv[0], *argv)
	else:
		return pid, f
	#endif
#enddef


def check_pid(pid):
	try:
		os.kill(pid, 0)
	except OSError:
		return False
	#endtry

	return True
#enddef


def dot(c='.'):
	sys.stdout.write(c)
	sys.stdout.flush()
#enddef


def main():
	args = docopt.docopt(__doc__, version=__version__)

	if args['--copy-keys'] and not check_pub_key(PUB_KEY_FN):
		raise Exception('i don\'t like the public key')
	#endif

	tag = args['-t']

	hosts = set()
	for i in HOSTS:
		host, *tags = i.split()
		if not tag or tag in tags:
			hosts.add(host)
		#endif
	#endfor

	# this fails when piping the output to less etc.
	try:
		cols, rows = os.get_terminal_size()
	except:
		cols, rows = None, None
	#endtry

	# TODO: the -t seems to be breaking logins to windows machines - figure shomething out
	#sshopts = '-t -o ConnectTImeout=2'
	sshopts = ''

	# TODO: why the fuck can't i use -t in script mode? (sending eof does not work, then)
	#if cols and not args['<script>']:
	if cols:
		sshopts += ' -t'
	#endif

	cmds = []
	for host in sorted(list(hosts)):
		if args['--user']:
			host_full = '%s@%s' % (args['--user'], host)
		else:
			host_full = host
		#endif

		if args['--copy-keys']:
			cmd = 'ssh-copy-id -i %s %s' % (PUB_KEY_FN, host_full)
		elif args['<script>']:
			if args['--sudo']:
				sudo = 'sudo'
			else:
				sudo = ''
			#endif

			#cmd = 'ssh %s %s \'sh -c "a=`mktemp`; cat >$a; chmod a+x $a; %s $a; rm $a"\'' % (sshopts, host_full, sudo)
			#cmd = 'ssh %s %s \'sh -c "cat >/tmp/ahojjj; chmod a+x /tmp/ahojjj; %s /tmp/ahojjj; rm /tmp/ahojjj"\'' % (sshopts, host_full, sudo)
			cmd = 'ssh %s %s "cat | %s sh"' % (sshopts, host_full, sudo)
		elif args['<command>']:
			cmd = 'ssh %s %s "%s"' % (sshopts, host_full, args['<command>'])
		#endif

		if args['--pass']:
			if not os.path.isfile('/usr/bin/sshpass'):
				raise Exception('/usr/bin/sshpass does not exist')
			#endif

			cmd = '/usr/bin/sshpass -p%s %s' % (args['--pass'], cmd)
		#endif

		cmds.append(cmd)
	#endfor

	forks = {}
	ins = {}
	outs = {}
	rets = {}

	total = len(cmds)
	i = 0
	cur_cmd = None
	last_ctrl_c = 0
	while 1:
		while cmds and len(forks) < MAX_FORKS:
			if DEBUG: dot('+')

			cmd = cmds.pop(0)
			pid, f = fork_it(cmd)

			if cols:
				fcntl.ioctl(f, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))  # send terminal size
			#endif

			if args['<script>']:
				data = open(args['<script>'], 'r').read()
				ins[cmd] = data + '\x04'  # EOF - does not work!
			#endif

			forks[cmd] = (pid, f)
			outs[cmd] = ''
		#endif

		if not cur_cmd:
			for cmd in sorted(list(outs.keys())):
				if cmd in forks: continue  # still active

				if rets[cmd] == 0:
					col = color.GREEN
				else:
					col = color.RED
				#endif

				i += 1
				print('%s(%d/%d) %s%s -> ret: %d%s' % (col, i, total, color.BOLD, cmd, rets[cmd], color.END))

				sys.stdout.write(outs[cmd])
				sys.stdout.flush()
				del outs[cmd]
			#endfor

			if not forks:
				break  # we're done
			elif not cols:
				pass  # we're not interactive, just wait for some fork to finish
			else:
				cur_cmd = sorted(list(forks.keys()))[0]

				i += 1
				print('%s(%d/%d) %s%s%s' % (color.YELLOW, i, total, color.BOLD, cur_cmd, color.END))

				if cur_cmd in outs:
					sys.stdout.write(outs[cur_cmd])
					del outs[cur_cmd]
				#endif

				pid, f = forks[cur_cmd]

				if cur_cmd in ins:
					inp = ins[cur_cmd]
					del ins[cur_cmd]
				else:
					inp = ''
				#endif
			#endif
		#endif

		r, w, x = [sys.stdin, ], [], [sys.stdin, ]
		for cmd, (pid, f) in forks.items():
			r.append(f)
			if (cmd == cur_cmd and inp) or cmd in ins:
				w.append(f)
			#endif
			x.append(f)
		#endfor

		r, w, x = select.select(r, w, x, 0)

		if not r and not w and not x:
			if DEBUG: dot()

			try:
				time.sleep(0.01)
			except KeyboardInterrupt:
				t = time.monotonic()
				if t - last_ctrl_c < 1: break
				last_ctrl_c = t
				inp += '\x03'  # ctrl-c
			#endtry

			continue
		else:
			if DEBUG: dot('_')
		#endif

		if sys.stdin in r:
			inp_ = sys.stdin.readline()
			if not inp_:
				inp += '\x04'  # EOF
			else:
				inp += inp_
			#endif
		#endif

		just_finished = set()
		for cmd, (pid, f) in forks.items():
			if f in r:
				try:
					out_ = os.read(f, 1024).decode()
				except:
					just_finished.add(cmd)
					out_ = None
				#endtry	

				if out_:
					if cmd == cur_cmd:
						sys.stdout.write(out_)
						sys.stdout.flush()
					else:
						outs[cmd] += out_
					#endif
				#endif
			#endif

			if f in w:
				if cmd == cur_cmd:
					os.write(f, inp.encode())
					inp = ''
				else:
					os.write(f, ins[cmd].encode())
					del ins[cmd]
				#endif
			#endif
		#endfor

		for cmd in just_finished:
			if DEBUG: dot('-')

			pid, f = forks[cmd]
			os.close(f)
			_, ret = os.waitpid(pid, 0)
			rets[cmd] = ret

			del forks[cmd]

			if cmd == cur_cmd:
				if ret == 0:
					col = color.GREEN
				else:
					col = color.RED
				#endif

				print('%sret: %d%s' % (col, ret, color.END))
				cur_cmd = None
			#endif
		#endfor
	#endif

	# TODO: a lot of this is cut-n-pasted from above
	for cmd, (pid, f) in forks.items():
		os.close(f)
		os.kill(pid, signal.SIGTERM)
		_, ret = os.waitpid(pid, 0)
		rets[cmd] = ret
	#endfor

	forks.clear()

	ret_stats = {}
	for cmd, ret in rets.items():
		if not ret in ret_stats: ret_stats[ret] = set()
		ret_stats[ret].add(cmd)
	#endfor

	s = []
	for ret in sorted(ret_stats.keys()):
		if ret == 0:
			col = color.GREEN
		else:
			col = color.RED
		#endif

		s.append('%s%s: %d' % (col, ret, len(ret_stats[ret])))
	#endfor
	s = ', '.join(s)

	print('rets: %s%s' % (s, color.END))
#enddef


if __name__ == '__main__':
	main()
#enddef
